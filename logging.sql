alter session set nls_length_semantics=char;

drop table tubrr_getinfo_log purge;
create table tubrr_getinfo_log(
    log_id          integer generated by default on null as identity not null constraint tubrr_getinfo_log_pk primary key using index reverse tablespace indx disable,
    log_time        timestamp,
    log_msg         varchar2(255),
    sid             number,
    serial#         number,
    username        varchar2(128),
    osuser          varchar2(128),
    ip_address      varchar2(20),
    terminal        varchar2(30),
    module          varchar2(48),
    host            varchar2(64),
    content         clob,
    call_stack      varchar2(1000),
--    subprogram      varchar2(255),
    error_stack     varchar2(1000),
    error_backtrace varchar2(1000)
) pctfree 0
partition by range(log_time) interval(numtoyminterval(1,'month')) (partition p_default values less than (date'2023-01-01'));


create or replace procedure ubrr_getinfo_log(p_log_apply in boolean default true, p_log_msg in varchar2 default null, p_log_content in clob default null) is
    pragma autonomous_transaction;
    l_ubrr_getinfo_log tubrr_getinfo_log%rowtype;
begin
    if p_log_apply then
--        l_ubrr_getinfo_log.log_id          := "A4M"."ISEQ$$_42828766".nextval;  -- generated always as identity
        l_ubrr_getinfo_log.log_time        := systimestamp;
        l_ubrr_getinfo_log.log_msg         := substr(p_log_msg, 1, 255);    
        l_ubrr_getinfo_log.sid             := sys_context('userenv', 'sid');
        l_ubrr_getinfo_log.serial#         := null;
        l_ubrr_getinfo_log.username        := sys_context('userenv', 'session_user');
        l_ubrr_getinfo_log.osuser          := sys_context('userenv', 'os_user');
        l_ubrr_getinfo_log.ip_address      := sys_context('userenv', 'ip_address');
        l_ubrr_getinfo_log.terminal        := sys_context('userenv', 'terminal');
        l_ubrr_getinfo_log.module          := sys_context('userenv', 'module');
        l_ubrr_getinfo_log.host            := sys_context('userenv', 'host');
        l_ubrr_getinfo_log.content         := p_log_content;
        l_ubrr_getinfo_log.call_stack      := substr(dbms_utility.format_call_stack, 1, 1000);
--        l_ubrr_getinfo_log.subprogram      := utl_call_stack.concatenate_subprogram(utl_call_stack.subprogram(dynamic_depth => 2)) || ' (line: ' || utl_call_stack.unit_line(dynamic_depth => 2) || ')';
        l_ubrr_getinfo_log.error_stack     := substr(dbms_utility.format_error_stack, 1, 1000);
        l_ubrr_getinfo_log.error_backtrace := substr(dbms_utility.format_error_backtrace, 1, 1000);
        
        insert into tubrr_getinfo_log values l_ubrr_getinfo_log;
        commit;
    end if;
end ubrr_getinfo_log;
/

create sequence seq_ubrr_getinfo;







-- if there are rows with unexptected LogMSG
select sid, group_name, infotype, count(1) cnt 
from (
    select 
        sid, 
        substr(log_msg, 1, instr(log_msg, ']')) group_name,
        substr(to_char(content), instr(content, '"InfoType"') + 14, instr(content, '"Format"') - instr(content, '"InfoType"') - 20) infotype
    from tubrr_getinfo_log)
where group_name like '%GetInfo%'
group by sid, group_name , infotype
having count(1) <> 2;




-- query to show aggregated results of the logging by InfoType
select
    infotype,
    count(1)  wait,
    min(diff) min_exec_time,
    max(diff) max_exec_time,
    numtodsinterval(avg(to_number(to_char(timestamp'0001-01-01 00:00:00.00000' + diff, 'sssss'))), 'second') avg_exec_time
from (
    select 
        infotype,
        max(log_time) - min(log_time) diff
    from (
        select 
            sid, 
            substr(log_msg, 1, instr(log_msg, ']')) group_name,
            log_time,
            substr(to_char(content), instr(content, '"InfoType"') + 14, instr(content, '"Format"') - instr(content, '"InfoType"') - 20) infotype
        from tubrr_getinfo_log
    )
    where group_name like '%GetInfo%'
    group by sid,
        group_name,
        infotype
    having count(1) = 2 -- there are START and [STOP|EXCEPTION] event
)
group by infotype;




-- query to show step by step results of the logging by group_name, InfoType
select 
    sid,
    group_name,
    infotype,
    count(1) wait,
    min(event)keep(dense_rank first order by log_time) sevent,
    min(log_time) stime,
    max(event)keep(dense_rank last order by log_time) eevent,
    max(log_time) etime,
    max(log_time) - min(log_time) diff,
    min(content)keep(dense_rank first order by log_time) parameters
from (
    select 
        sid, 
        substr(log_msg, 1, instr(log_msg, ']')) group_name,
        substr(log_msg, instr(log_msg, ' ') + 1) event,
        log_time,
        to_char(substr(content, 1, 255)) content,
        substr(to_char(content), instr(content, '"InfoType"') + 14, instr(content, '"Format"') - instr(content, '"InfoType"') - 20) infotype
    from tubrr_getinfo_log
)
where group_name like '%GetInfo%'
    and infotype = 'GetClientDetailsEx'
group by sid,
    group_name,
    infotype
--order by substr(group_name, 9, instr(group_name, ']') - 1);
order by diff desc;





with source as (
    select 
        1457 sid, 53213 serial#, 
        to_date('21.06.2022 17:18:49', 'dd.mm.yyyy hh24:mi:ss') stime,
        to_date('21.06.2022 17:18:49', 'dd.mm.yyyy hh24:mi:ss') etime
    from v$session where sid = userenv('sid')),
sbq as (
    select /*+no_merge*/ 
        sql_id, sql_exec_id, count(1) rowcount, sum(tm_delta_cpu_time) cpu, sum(tm_delta_db_time) ela
    from v$active_session_history ash
        join source s on s.sid = ash.session_id and s.serial# = ash.session_serial#
--    where sample_time between s.stime and s.etime
    group by sql_id, sql_exec_id)

select sbq.*, 
    (select object_name || ' (' || lower(object_type) || ')' from user_objects where object_id = s.program_id) || '(line: ' || s.program_line# || ')'object_name,
    s.* 
from sbq, v$sql s 
where sbq.sql_id = s.sql_id(+)
order by rowcount desc;
